# MOT Club 아키텍처

## 시스템 아키텍처

### 전체 구조

```
┌─────────────────────────────────────────┐
│          사용자 (브라우저)                │
└───────────────┬─────────────────────────┘
                │
                ├─> 정적 파일 (Next.js CDN)
                │
                ▼
┌─────────────────────────────────────────┐
│     Frontend (Next.js 16.0.3)           │
│     - React 18.3.1 (다운그레이드)        │
│     - TypeScript 5.3.3                  │
│     - Tailwind CSS 3.4.0                │
│     - Port: 3002                        │
└───────────────┬─────────────────────────┘
                │
                │ HTTP/REST API
                │ /api/* → Proxy
                │
                ▼
┌─────────────────────────────────────────┐
│     Backend (Spring Boot)               │
│     - REST API                          │
│     - Port: 8084 (dev) / 80 (prod)     │
└───────────────┬─────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│          Database                       │
│          (백엔드에서 관리)                │
└─────────────────────────────────────────┘
```

## 프론트엔드 아키텍처

### Next.js App Router 구조

```
app/
├── layout.tsx                  # 루트 레이아웃 (AuthProvider, SideMenu)
├── page.tsx                    # 홈페이지
├── login/                      # 인증 페이지
├── admin/                      # 관리자 페이지
├── qna/                        # Q&A
│   ├── page.tsx
│   ├── [id]/page.tsx          # 동적 라우팅
│   └── write/page.tsx
├── library/                    # 자료실
├── learning/                   # 학습 프로그램
├── opinions/                   # 연구 의견
└── api/                        # API Routes
```

### 컴포넌트 구조

```
components/
├── common/                     # 공통 컴포넌트
│   ├── PDFViewer.tsx
│   ├── FileViewer.tsx
│   ├── QuillEditor.tsx
│   └── RichTextEditor.tsx
├── admin/                      # 관리자 전용
│   ├── UserManagement.tsx
│   ├── ExpertManagement.tsx
│   └── NoticeManagement.tsx
├── qna/                        # Q&A 전용
│   ├── QuestionForm.tsx
│   ├── QuestionList.tsx
│   └── AnswerForm.tsx
└── library/                    # 자료실 전용
    └── LibraryPage.tsx
```

### 상태 관리

```
context/
└── AuthContext.tsx
    ├── 인증 상태 관리
    ├── 사용자 정보 (id, email, name, role)
    ├── 로그인/로그아웃 함수
    └── 세션 스토리지 연동
```

### API 통신 계층

```
utils/
├── api.ts                      # 공통 API 함수
│   ├── get(url, config?)
│   ├── post(url, data, config?)
│   ├── put(url, data, config?)
│   └── delete(url, config?)
│
├── learningProgramApi.ts       # 학습 프로그램 API
├── customProgramApi.ts         # 커스텀 프로그램 API
└── unifiedSearchApi.ts         # 통합 검색 API

config/
└── api.ts
    ├── API_ENDPOINTS           # 엔드포인트 상수
    └── API_BASE_URL            # 환경별 기본 URL
```

## 라우팅 아키텍처

### Next.js Rewrites (Proxy)

```javascript
// next.config.js
async rewrites() {
  return [
    {
      source: '/api/:path*',
      destination: `${apiUrl}/api/:path*`  // 백엔드로 프록시
    }
  ]
}
```

### 환경별 API URL

| 환경 | API URL | 설명 |
|------|---------|------|
| 로컬 | http://localhost:8084 | 로컬 백엔드 (포트 8084) |
| 개발 | http://192.168.0.101:8084 | 내부 개발 서버 |
| 스테이징 | http://www.motclub.co.kr | 운영 서버 |
| 프로덕션 | http://www.motclub.co.kr | 운영 서버 |

### 현재 로컬 실행 환경 (2026-02-03)
```
프론트엔드: npm run dev:local → http://localhost:3002
백엔드: gradlew bootRun → http://localhost:8084
CORS 설정: localhost:3000, 3001, 3002, 13000 허용
DB: PostgreSQL 12.22 (192.168.0.101:5432/mot_db)
개발 도구: Spring Boot DevTools (LiveReload 포트 35729)
```

## 인증 아키텍처

### 인증 흐름

```
1. 사용자 로그인 요청
   ↓
2. POST /api/login (백엔드)
   ↓
3. 백엔드에서 인증 처리
   ↓
4. 사용자 정보 반환
   ↓
5. sessionStorage에 사용자 정보 저장
   ↓
6. AuthContext 상태 업데이트
   ↓
7. 페이지 리다이렉트
```

### 역할 기반 접근 제어 (RBAC)

```typescript
type UserRole = 'USER' | 'ADMIN' | 'EXPERT';

interface User {
  id: number;
  email: string;
  name: string;
  role: UserRole;
}

// 역할별 권한
- USER: 기본 사용자 (읽기, 질문 작성)
- EXPERT: 전문가 (답변 작성)
- ADMIN: 관리자 (모든 관리 기능)
```

## 빌드 아키텍처

### Next.js Standalone 모드

```
빌드 결과 (dist/standalone/)
├── server.js               # 독립 실행 가능한 서버
├── .next/                  # 빌드 파일
│   ├── static/
│   └── server/
├── public/                 # 정적 파일 (복사 필요)
└── node_modules/           # 필수 의존성만 포함
```

### Docker 다단계 빌드

```dockerfile
1. deps 단계
   - package.json, package-lock.json 복사
   - 프로덕션 의존성만 설치

2. builder 단계
   - 전체 소스 코드 복사
   - 개발 의존성 포함 설치
   - Next.js 빌드 실행

3. runner 단계 (최종 이미지)
   - Node.js 18 Alpine
   - 빌드 결과물만 복사
   - 최소 용량 (최적화)
   - 헬스체크 설정
```

## 파일 처리 아키텍처

### PDF 처리

```
react-pdf + pdfjs-dist
├── PDF.js 워커: /public/pdf.worker.min.js
├── Webpack 설정으로 워커 경로 지정
└── PDFViewer 컴포넌트에서 렌더링
```

### Excel 처리

```
xlsx 라이브러리
├── 파일 다운로드
├── JSON 변환
└── 엑셀 생성/내보내기
```

### 리치 텍스트 에디터

```
react-quill + TinyMCE
├── Quill: 간단한 에디터
├── TinyMCE: 고급 에디터
└── HTML 콘텐츠 저장
```

## 성능 최적화 전략

### 빌드 최적화
- Standalone 모드로 불필요한 파일 제거
- SWC 컴파일러 사용 (Babel 대체)
- Turbopack 지원 (개발 서버 속도 향상)

### 런타임 최적화
- 코드 스플리팅 (자동)
- 이미지 최적화 (Next.js Image)
- 동적 임포트 (필요시)

### 메모리 관리
- 빌드 시 8GB 메모리 할당
- 프로덕션 이미지: Alpine Linux (경량)

## 배포 아키텍처

### 현재 배포 방식 (추정)

```
수동 배포
├── 로컬에서 빌드
├── Docker 이미지 생성
├── 이미지 레지스트리에 푸시 (선택)
├── 운영 서버로 전송
└── 서버에서 컨테이너 실행
```

### 환경별 빌드 스크립트

```bash
# 로컬
npm run build:local

# 개발
npm run build:dev

# 스테이징
npm run build:staging

# 프로덕션
npm run build:prod && npm run copy-public
```

## 확장성 고려사항

### 수평 확장
- Standalone 빌드로 여러 인스턴스 실행 가능
- 로드 밸런서를 통한 트래픽 분산
- 세션 스토리지 → Redis 세션으로 마이그레이션 고려

### 수직 확장
- 메모리: 현재 8GB 할당 (빌드)
- CPU: 멀티 코어 활용 가능

## 보안 아키텍처

### 클라이언트 측 보안
- XSS 방지: React의 자동 이스케이핑
- CSRF: 백엔드에서 처리 (추정)
- 환경 변수: NEXT_PUBLIC_ 접두사로 노출 제어

### 서버 측 보안
- 세션 기반 인증
- 역할 기반 접근 제어
- API 프록시로 백엔드 URL 숨김

## 모니터링 및 로깅

### 헬스체크
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s \
  CMD node -e "require('http').get('http://localhost:3002')"
```

### 접근 로그
- 관리자 페이지에서 접근 로그 관리 기능 제공
- Spring Boot DevTools LiveReload (포트 35729)

## 성능 최적화 및 튜닝 (실제 분석 및 추천사항)

### 1. 초기 로딩 속도 분석

**현재 성능 메트릭스 (로컬 환경)**
- 백엔드 시작 시간: **7.265초** ✅ (정상)
- 프론트엔드 빌드: **24.3초** (프로덕션 빌드)
- 개발 모드 Hot Reload: **즉시** ✅
- 초기 페이지 로딩: **~2-3초** (DB 쿼리 포함)

**느린 이유 분석:**
- PostgreSQL 쿼리 응답 (네트워크 레이턴시 포함)
- N+1 쿼리 문제 (각 항목의 연관 데이터 개별 조회)
- 인덱스 부재로 인한 Full Table Scan
- 프론트엔드 번들 크기 (PDF, Excel 라이브러리)

### 실측: `/learning` 페이지 느린 이유 (개발 모드)

- 측정 요약 (로컬 dev 서버):
  - 첫 요청: `GET /learning` **200 in 8.8s** (compile: 8.8s, render: 61ms)
  - 재요청: `GET /learning` **55ms** (compile: 13ms, render: 42ms)
  - 측정 방법: PowerShell에서 Invoke-WebRequest로 요청 (Stopwatch 측정)

- 원인 결론:
  - **개발 모드(On-demand compilation)**: Next.js(webpack) 개발 서버가 첫 요청 시 해당 페이지의 번들을 컴파일하여 첫 로드가 느립니다. 로그에 `compile: 8.8s`로 나타남. 이후 요청은 캐시되어 매우 빠릅니다.
  - 백엔드(API) 처리 시간은 짧음(여러 `/api/*` 호출이 빠르게 응답하며 DB 쿼리도 ms 단위로 완료됨). 즉, 느린 구간은 프론트엔드의 개발용 컴파일(빌드) 지연입니다.

- 권장 조치:
  1. **개발 중 불편 최소화**: 주요 페이지를 사전에 한 번 방문하거나 `next dev` 실행 후 페이지를 미리 열어 둡니다. 개발용 컴파일을 피하려면 `next build && next start`로 프로덕션 서버를 띄워 성능을 확인합니다.
  2. **CI/Prod 검증**: 프로덕션 성능은 `npm run build` → `npm run start`로 확인하세요. Production은 서버사이드 컴파일 지연이 없으며 빌드된 결과가 사용됩니다.
  3. **개발 서버 속도 개선**: Turbopack(가능시)로 전환하거나 `cpus` 설정을 늘려 dev 컴파일 성능을 향상시킵니다. (`next.config.js`의 `experimental.cpus` 조정)
  4. **런타임 최적화**: `getStaticProps`/ISR(Incremental Static Regeneration)로 정적 페이지 생성 가능하면 적용, 클라이언트 요청을 줄이도록 API 응답을 가볍게 유지 및 캐싱 적용.
  5. **프론트 번들 분리**: PDF/Excel 관련 라이브러리는 동적 임포트로 분리하여 초기 번들 크기 감소.

> 요약: 현재 `/learning`의 첫 로드 지연은 개발 모드의 on-demand 컴파일(webpack) 때문이며, 백엔드 응답 지연은 아니므로 프로덕션 빌드 또는 dev 컴파일 최적화로 해결됩니다.

### 2. 데이터베이스 쿼리 최적화

#### N+1 문제 식별 및 해결

**문제 패턴:**
```sql
-- Question 목록 조회 (쿼리 1)
SELECT * FROM question WHERE status = 'PUBLISHED' LIMIT 20;

-- 각 Question의 author 조회 (쿼리 2~21: 20개)
SELECT * FROM user WHERE id = 1;
SELECT * FROM user WHERE id = 2;
...
-- 총 21개 쿼리 발생!
```

**Spring Data JPA 해결법:**

```java
// ❌ 나쁜 예: LazyLoading
@Entity
public class Question {
    @ManyToOne(fetch = FetchType.LAZY)
    private User author;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Answer> answers;
}

// ✅ 해결 방법 1: JPQL JOIN FETCH
@Repository
public interface QuestionRepository extends JpaRepository<Question, Long> {
    @Query("SELECT q FROM Question q " +
           "JOIN FETCH q.author a " +
           "LEFT JOIN FETCH q.answers ans " +
           "WHERE q.status = 'PUBLISHED' " +
           "ORDER BY q.createdAt DESC")
    List<Question> findPublishedWithDetails(Pageable pageable);
}

// ✅ 해결 방법 2: EntityGraph (권장)
@Repository
public interface QuestionRepository extends JpaRepository<Question, Long> {
    @EntityGraph(attributePaths = {"author", "answers"})
    @Query("SELECT q FROM Question q WHERE q.status = 'PUBLISHED'")
    Page<Question> findPublished(Pageable pageable);
}

// ✅ 해결 방법 3: QueryDSL (복잡한 쿼리)
public List<Question> findPublishedQuestions() {
    return queryFactory
        .selectFrom(question)
        .innerJoin(question.author, user).fetchJoin()
        .leftJoin(question.answers, answer).fetchJoin()
        .where(question.status.eq(QuestionStatus.PUBLISHED))
        .orderBy(question.createdAt.desc())
        .fetch();
}
```

### 3. 추천 인덱스 추가 (즉시 적용 권장)

```sql
-- ============ 기본 인덱스 ============
-- Question 테이블
CREATE INDEX idx_question_author_id ON question(author_id);
CREATE INDEX idx_question_created_at ON question(created_at DESC);
CREATE INDEX idx_question_status ON question(status);
CREATE INDEX idx_question_status_created ON question(status, created_at DESC);

-- Answer 테이블
CREATE INDEX idx_answer_question_id ON answer(question_id);
CREATE INDEX idx_answer_author_id ON answer(author_id);
CREATE INDEX idx_answer_created_at ON answer(created_at DESC);

-- User 테이블
CREATE INDEX idx_user_email ON user(email);
CREATE INDEX idx_user_role ON user(role);

-- LearningProgram 테이블
CREATE INDEX idx_learning_program_user_id ON learning_program(user_id);
CREATE INDEX idx_learning_program_status ON learning_program(status);

-- Library 테이블
CREATE INDEX idx_library_category_id ON library(category_id);
CREATE INDEX idx_library_created_at ON library(created_at DESC);

-- ============ 복합 인덱스 (자주 함께 조회) ============
CREATE INDEX idx_question_author_created ON question(author_id, created_at DESC);
CREATE INDEX idx_answer_question_author ON answer(question_id, author_id);
CREATE INDEX idx_library_category_created ON library(category_id, created_at DESC);

-- ============ 검색 최적화 인덱스 ============
CREATE INDEX idx_question_title_search ON question USING GIN(to_tsvector('korean', title));
CREATE INDEX idx_question_content_search ON question USING GIN(to_tsvector('korean', content));
```

**적용 SQL (한번에 실행):**
```sql
-- PostgreSQL 콘솔에서 실행
psql -U mot_user -d mot_db -h 192.168.0.101

-- 복사-붙여넣기로 위 인덱스 생성 쿼리 일괄 실행
-- 기존 인덱스 확인
SELECT * FROM pg_indexes WHERE tablename = 'question';
```

### 4. 프론트엔드 성능 최적화

#### 코드 스플리팅 (번들 사이즈 감소)

```typescript
// Before: 모든 컴포넌트를 초기 로딩
import PDFViewer from '@/components/common/PDFViewer';
import ExcelExporter from '@/components/common/ExcelExporter';

// After: 동적 로딩 (필요할 때만 로드)
import dynamic from 'next/dynamic';

const PDFViewer = dynamic(() => import('@/components/common/PDFViewer'), {
  loading: () => <div className="animate-pulse">PDF 로딩 중...</div>,
  ssr: false  // pdfjs-dist는 브라우저 전용
});

const ExcelExporter = dynamic(() => import('@/components/common/ExcelExporter'), {
  loading: () => <div>내보내기 준비 중...</div>,
  ssr: false  // xlsx는 클라이언트 전용
});
```

#### 이미지 최적화

```typescript
import Image from 'next/image';

// 최적화된 이미지 로딩
<Image
  src="/images/course-thumbnail.jpg"
  alt="과정 썸네일"
  width={300}
  height={200}
  priority  // LCP (Largest Contentful Paint) 최적화
  placeholder="blur"  // 로딩 중 블러 표시
  quality={75}  // WebP 압축
/>
```

#### 번들 분석
```bash
npm run build
npm install -g webpack-bundle-analyzer

# Bundle 분석 (package.json에 script 추가)
"analyze": "ANALYZE=true next build"
npm run analyze
```

### 5. 백엔드 성능 최적화

#### 데이터베이스 연결 풀 튜닝

```yaml
# Backend/mot/src/main/resources/application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20  # 최대 연결 수 (기본 10)
      minimum-idle: 5        # 최소 유휴 연결
      connection-timeout: 20000  # 20초
      idle-timeout: 300000   # 5분
      max-lifetime: 1200000  # 20분
      leak-detection-threshold: 15000  # 연결 누수 감지

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        jdbc:
          batch_size: 20
          fetch_size: 50
        order_inserts: true
        order_updates: true
```

#### 페이지네이션 구현 (필수)

```java
// QuestionController.java
@GetMapping("/api/questions")
public Page<QuestionResponseDto> getQuestions(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "20") int size,
    @RequestParam(defaultValue = "createdAt") String sortBy
) {
    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy).descending());
    return questionService.getQuestions(pageable);
}

// QuestionService.java
@Service
public class QuestionService {
    
    @EntityGraph(attributePaths = {"author"})
    public Page<Question> getQuestions(Pageable pageable) {
        return questionRepository.findAll(pageable);
    }
}
```

#### 캐싱 (선택)

```java
// Redis 캐싱 설정
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("questions", "answers", "users");
    }
}

// 서비스에서 사용
@Service
public class QuestionService {
    
    @Cacheable(value = "questions", key = "#id")
    public Question getQuestionById(Long id) {
        return questionRepository.findById(id)
            .orElseThrow(() => new ResourceNotFoundException("Question not found"));
    }
    
    @CacheEvict(value = "questions", key = "#question.id")
    public Question updateQuestion(Question question) {
        return questionRepository.save(question);
    }
}
```

### 6. 쿼리 성능 모니터링

#### 느린 쿼리 로깅 설정

```yaml
# application.yml
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.springframework.jdbc.core: DEBUG
    
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true
        use_sql_comments: true
        session:
          events:
            log: true
```

#### 개발 중 모니터링 도구

```
1. H2 콘솔: http://localhost:8084/h2-console
   - JDBC URL: jdbc:postgresql://192.168.0.101:5432/mot_db
   
2. Spring Actuator: http://localhost:8084/actuator
   - Health: /actuator/health
   - Metrics: /actuator/metrics
   - Env: /actuator/env
   
3. Chrome DevTools
   - Network 탭: 응답 시간 확인
   - Performance 탭: 렌더링 성능 분석
```

### 7. 배포 후 모니터링 및 튜닝 체크리스트

- [ ] 데이터베이스 인덱스 생성 완료
- [ ] N+1 쿼리 문제 EntityGraph로 해결
- [ ] 프론트엔드 번들 동적 로딩 적용
- [ ] 이미지 최적화 및 lazy loading 적용
- [ ] 백엔드 페이지네이션 구현
- [ ] 데이터베이스 연결 풀 설정 완료
- [ ] 느린 쿼리 로깅 활성화
- [ ] CDN 또는 캐시 레이어 고려
- [ ] 정기적인 성능 모니터링 (주 1회)

## 데이터 흐름

### 읽기 작업
```
사용자 요청
  ↓
Next.js 페이지
  ↓
React 컴포넌트
  ↓
API 유틸리티 (utils/api.ts)
  ↓
Axios HTTP 요청
  ↓
Next.js Proxy (/api/*)
  ↓
Spring Boot 백엔드
  ↓
데이터베이스
  ↓
(역순으로 응답)
```

### 쓰기 작업
```
사용자 입력 (폼)
  ↓
상태 관리 (useState)
  ↓
폼 제출
  ↓
API POST/PUT 요청
  ↓
백엔드 처리
  ↓
성공/실패 응답
  ↓
UI 업데이트 또는 리다이렉트
```
